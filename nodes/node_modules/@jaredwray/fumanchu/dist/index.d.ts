import * as HandlebarsLib from 'handlebars';

declare enum HelperRegistryCompatibility {
    NODEJS = "nodejs",
    BROWSER = "browser"
}
type HelperFilter = {
    name?: string;
    category?: string;
    compatibility?: HelperRegistryCompatibility;
};
type Helper = {
    name: string;
    category: string;
    compatibility?: HelperRegistryCompatibility;
    fn: ((...arguments_: any[]) => string);
};
declare class HelperRegistry {
    private readonly _helpers;
    constructor();
    init(): void;
    register(helper: Helper): boolean;
    registerHelpers(helpers: Helper[]): void;
    has(name: string): boolean;
    filter(filter: HelperFilter): Helper[];
    loadHandlebars(handlebars: any): void;
    swapHelpers(handlebars: any): void;
}

/**
 * Handlebars library not initiated with helpers
 * @type {Handlebars}
 */
declare const Handlebars: typeof HandlebarsLib;
/**
 * Fumanchu Handlebars instance not initiated with helpers
 * @type {Handlebars}
 */
declare const handlebars: typeof HandlebarsLib;
/**
 * Fumanchu Handlebars helpers
 */
declare const helpers: {
    (groups: any, options: any): any;
    utils: any;
};
/**
 * Create a new Handlebars instance with Fumanchu helpers
 * @returns {Promise<Handlebars>}
 */
declare function createHandlebars(): Promise<typeof HandlebarsLib>;
/**
 * @typedef {Object} FumanchuCachingOptions
 * @property {number|string} [ttl] - Time to Live - If you set a number it is miliseconds, if you set a string it is a human-readable
 * format such as `1s` for 1 second or `1h` for 1 hour. Setting undefined means that it will use the default time-to-live. If both are
 * undefined then it will not have a time-to-live.
 * @property {boolean} [useClone] - If true, it will clone the value before returning it. If false, it will return the value directly. Default is true.
 * @property {number} [lruSize] - The size of the LRU cache. If set to 0, it will not use LRU cache. Default is 0.
 * @property {number} [checkInterval] - The interval to check for expired items. If set to 0, it will not check for expired items. Default is 0.
 */
type FumanchuCachingOptions = {
    ttl?: number | string;
    useClone?: boolean;
    lruSize?: number;
    checkInterval?: number;
};
type FumanchuOptions = {
    handlebars?: typeof HandlebarsLib;
    helpers?: Record<string, Function>;
    name?: string | string[];
    include?: HelperFilter[];
    exclude?: HelperFilter[];
    caching?: boolean | FumanchuCachingOptions;
};
/**
 * Will return a Handlebars instance with Fumanchu helpers (experimental)
 * @returns {Handlebars} Handlebars instance with helpers
 */
declare function fumanchu(options?: FumanchuOptions): typeof HandlebarsLib;

export { type FumanchuCachingOptions, type FumanchuOptions, Handlebars, type HelperFilter, HelperRegistry, createHandlebars, fumanchu, handlebars, helpers };
